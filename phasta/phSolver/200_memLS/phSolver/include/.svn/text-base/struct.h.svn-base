   
// Copyright Â©2011 UCSD
// Created by Mahdi Esmaily Moghadam
// contact memt63@gmail.com for reporting the bugs.

//     Some defenitions
#define LS_TYPE_CG 1
#define LS_TYPE_GMRES 2
#define LS_TYPE_NS 3
#define BC_TYPE_Dir 0
#define BC_TYPE_Neu 1
#define BCOP_TYPE_ADD 0
#define BCOP_TYPE_PRE 1
 
//     Communication structure
typedef struct {
   int foC;// = false;              // Free of created          (USE)
   int masF;                        // If this the master       (USE)
   int master;                      // Master ID                (USE)
   int task;                        // ID of this proc.         (USE)
   int tF;                          // Task in FORTRAN indexing (USE)
   int nTasks;                      // Total number of tasks    (USE)
   MPI_Aint comm;                   // MPI communicator         (IN)
} memLS_commuType;
/*
//     LHS matrix related data     
typedef struct {
   int foC;// = false;        // Free or created                (USE)
   int coupledFlag;        // Neu: P/Q coupling              (USE)
   int sharedFlag;// = false; // Neu: shared between proces     (USE)
   int incFlag;                  // Included in the computations   (IN)
   int nNo;// = 0;            // Number of nodes                (IN)
   int dof;                // Degrees of freedom for val     (IN)
   int bGrp;// = BC_TYPE_Dir; // Dir/Neu                        (IN)
   int reserved;                 // Only for data alignment
   int *glob;              // Global node number             (IN)
   double nS;              // ||Sai||**2D0                   (USE)
   double res;// = 0D0;       // Neu: P = res*Q                 (IN)
   double **val;           // nodal Sai for Neu              (IN)
   double **valM;          // Neu W*Sai                      (TMP)
} memLS_faceType;
      
typedef struct {
   int ptr;       // Pointer to start of data for commu (only 2 proc shared points)
   int n;         // Number of data to be commu  (only 2 proc shared points)
   int tag;       // Commu tag
   int req;       // Commu req
   int nBl;       // Number of blocks for commu  (for 3 < proc shared points)
   int reserved;  // Only for data alignment
   int *blPtr;    // Pointer to beggining of each block (for 3 < proc shared points)
   int *blN;      // Length of each block (for 3 < proc shared points)
} memLS_cSType;

typedef struct {
   int foC;// = false;        // Free or created                (USE)
   int gnNo;// = 0;           // Global number of nodes      (IN)
   int nNo;// = 0;            // Number of nodes             (IN)
   int nnz;// = 0;            // Number of non-zero in lhs   (IN)
   int nFaces;// = 0;         // Number of faces             (IN)
   int mynNo;              // nNo of this proc            (USE)
   int *colPtr;            // Column pointer              (USE)
   int **rowPtr;           // Row pointer                 (USE)
   int *diagPt;            // Diagonal pointer            (USE)
   int *map;               // Mapping of nodes            (USE)
   memLS_commuType commu;
   memLS_cSType *cS;
   memLS_faceType *face;
} memLS_lhsType;
*/
//     LS related structures
typedef struct {
   int suc;       // Successful solving          (OUT)
   int mItr;      // Maximum iteration           (IN)
   int sD;        // Space dimension             (IN)
   int itr;       // Number of iteration         (OUT)
   int cM;        // Number of Ax multiply       (OUT)
   int cN;        // Number of |x| norms         (OUT)
   int cD;        // Number of <x.y> dot products(OUT)
   int reserve;   // Only for data alignment     (-)
   double absTol; // Absolute tolerance          (IN)
   double relTol; // Relative tolerance          (IN)
   double iNorm;  // Initial norm of residual    (OUT)
   double fNorm;  // Final norm of residual      (OUT)
   double dB;     // Res. rduction in last itr.  (OUT)
   double callD;  // Calling duration            (OUT)
} memLS_subLsType;

typedef struct {
   int foC;// = false;   // Free of created             (USE)
   int LS_type;            // Which one of LS             (IN)
   int Resm;               // Contribution of mom. res.   (OUT)
   int Resc;               // Contribution of cont. res.  (OUT)
   memLS_subLsType GM;
   memLS_subLsType CG;
   memLS_subLsType RI;
} memLS_lsType;
