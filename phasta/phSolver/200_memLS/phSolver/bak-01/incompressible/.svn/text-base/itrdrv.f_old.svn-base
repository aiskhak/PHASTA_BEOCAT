      subroutine itrdrv (y,         ac,         
     &                   uold,      x,         
     &                   iBC,       BC,         
     &                   iper,      ilwork,     shp,       
     &                   shgl,      shpb,       shglb,
     &                   ifath,     velbar,     nsons ) 
c
c----------------------------------------------------------------------
c
c This iterative driver is the semi-discrete, predictor multi-corrector 
c algorithm. It contains the Hulbert Generalized Alpha method which
c is 2nd order accurate for Rho_inf from 0 to 1.  The method can be
c made  first-order accurate by setting Rho_inf=-1. It uses CGP and
c GMRES iterative solvers.
c
c working arrays:
c  y      (nshg,ndof)           : Y variables
c  x      (nshg,nsd)            : node coordinates
c  iBC    (nshg)                : BC codes
c  BC     (nshg,ndofBC)         : BC constraint parameters
c  iper   (nshg)                : periodicity table
c
c
c Zdenek Johan,  Winter 1991.  (Fortran 90)
c Alberto Figueroa, Winter 2004.  CMM-FSI
c Irene Vignon, Fall 2004. Impedance BC
c----------------------------------------------------------------------
c
      use pvsQbi     !gives us splag (the spmass at the end of this run 
      use specialBC !gives us itvn
      use timedata   !allows collection of time series
      use convolImpFlow !uses flow history and impedance for convolution
      use spat_var_eps !use spatial varying eps_ls
c      use readarrays !reads in uold and acold
      
        include "common.h"
        include "mpif.h"
        include "auxmpi.h"
c
        real*8 NewQImp(0:MAXSURF) !temporary unknown for the flow
                        !rate that needs to be added to the flow history
        
        real*8    y(nshg,ndof),              ac(nshg,ndof),           
     &	          yold(nshg,ndof),           acold(nshg,ndof),
     &            u(nshg,nsd),               uold(nshg,nsd),
     &            x(numnp,nsd),              solinc(nshg,ndof),
     &            BC(nshg,ndofBC),           tf(nshg,ndof)

c
        real*8    res(nshg,ndof)
c     
        real*8    shp(MAXTOP,maxsh,MAXQPT),  
     &            shgl(MAXTOP,nsd,maxsh,MAXQPT), 
     &            shpb(MAXTOP,maxsh,MAXQPT),
     &            shglb(MAXTOP,nsd,maxsh,MAXQPT) 
c
        integer   rowp(nshg,nnz),         colm(nshg+1),
     &            iBC(nshg),
     &            ilwork(nlwork),
     &            iper(nshg),            ifuncs(6)

        integer stopjob
        character*10 cname2
        character*5  cname
        integer i_redist_counter
        real*8 redist_toler_previous
c
c  stuff for dynamic model s.w.avg and wall model
c
        dimension ifath(numnp),    velbar(nfath,ndof),  nsons(nfath)

        dimension wallubar(2),walltot(2)
c     
c.... For Farzin's Library
c
        integer eqnType, prjFlag, presPrjFlag, verbose
c
        real*8, allocatable, dimension(:,:) :: aperm,  atemp, atempS
        real*8, allocatable, dimension(:,:,:) :: apermS

        real*8, allocatable, dimension(:,:) :: lhsP, lhsK, lhsS
        real*8   almit, alfit, gamit
c
        character*1024    servername
        character*20    fname1,fmt1
        character*20    fname2,fmt2,fnamer2
        character*60    fnamepold, fvarts
        character*4     fieldybar
        integer         iarray(50) ! integers for headers

        real*8 rerr(nshg,numerr),ybar(nshg,5) , uhess(nshg,27),
     &         gradu( nshg, 9 )
        real*8 elem_size(numel), elemb_size(numelb)
        real*8 elem_size_min, elem_size_mintmp
     
     
c
        real*8 gradphi(nshg,3), gradphimag(nshg), maxgradphi
	integer igradphi

        call SolverLicenseServer(servername)
c
c only master should be verbose
c

        if(numpe.gt.0 .and. myrank.ne.master)iverbose=0  
c

        inquire(file='xyzts.dat',exist=exts)
       
        if(exts) then
           
           open(unit=626,file='xyzts.dat',status='old')
           read(626,*) ntspts, freq, tolpt, iterat, varcod
           call sTD             ! sets data structures
           
           do jj=1,ntspts       ! read coordinate data where solution desired
              read(626,*) ptts(jj,1),ptts(jj,2),ptts(jj,3)
           enddo
           close(626)

           varts = zero

        endif
c
c.... open history and aerodynamic forces files
c
        if (myrank .eq. master) then
           open (unit=ihist,  file=fhist,  status='unknown')
           open (unit=iforce, file=fforce, status='unknown')
           open (unit=76, file="fort.76", status='unknown')
        endif
c
c.... initialize
c     
        ifuncs(:)  = 0              ! func. evaluation counter
        istep  = 0
        yold   = y
        acold  = ac

        rerr = zero
        ybar = zero
c
c.... ---------------> initialize Farzin's Library <---------------
c
c.... assign parameter values
c     
        do i = 1, 100
           numeqns(i) = i
        enddo
        nKvecs       = Kspace
        prjFlag      = iprjFlag
        presPrjFlag  = ipresPrjFlag
        verbose      = iverbose
c
c.... determine how many scalar equations we are going to need to solve
c
      nsolt=mod(impl(1),2)      ! 1 if solving temperature
      nsclrsol=nsolt+nsclr      ! total number of scalars solved At
                                ! some point we probably want to create
                                ! a map, considering stepseq(), to find
                                ! what is actually solved and only
                                ! dimension lhs to the appropriate
                                ! size. (see 1.6.1 and earlier for a
                                ! "failed" attempt at this).


      nsolflow=mod(impl(1),100)/10  ! 1 if solving flow
      
c
c.... Now, call Farzin's lesNew routine to initialize
c     memory space
c
      call genadj(colm, rowp, icnt )  ! preprocess the adjacency list

      nnz_tot=icnt ! this is exactly the number of non-zero blocks on
                   ! this proc

      if (nsolflow.eq.1) then
         lesId   = numeqns(1)
         eqnType = 1
         nDofs   = 4
         call myfLesNew( lesId,   41994,
     &                 eqnType,
     &                 nDofs,          minIters,       maxIters,
     &                 nKvecs,         prjFlag,        nPrjs,
     &                 presPrjFlag,    nPresPrjs,      epstol(1),
     &                 prestol,        verbose,        statsflow,
     &                 nPermDims,      nTmpDims,      servername  )
         
         allocate (aperm(nshg,nPermDims))
         allocate (atemp(nshg,nTmpDims))
         allocate (lhsP(4,nnz_tot))
         allocate (lhsK(9,nnz_tot))

         call readLesRestart( lesId,  aperm, nshg, myrank, lstep,
     &                        nPermDims )

      else
         nPermDims = 0
         nTempDims = 0
      endif


      if(nsclrsol.gt.0) then
       do isolsc=1,nsclrsol
         lesId       = numeqns(isolsc+1)
         eqnType     = 2
         nDofs       = 1
         presPrjflag = 0        
         nPresPrjs   = 0       
         prjFlag     = 1
         indx=isolsc+2-nsolt ! complicated to keep epstol(2) for
                             ! temperature followed by scalars
         call myfLesNew( lesId,            41994,
     &                 eqnType,
     &                 nDofs,          minIters,       maxIters,
     &                 nKvecs,         prjFlag,        nPrjs,
     &                 presPrjFlag,    nPresPrjs,      epstol(indx),
     &                 prestol,        verbose,        statssclr,
     &                 nPermDimsS,     nTmpDimsS,   servername )
       enddo
c
c  Assume all scalars have the same size needs
c
       allocate (apermS(nshg,nPermDimsS,nsclrsol))
       allocate (atempS(nshg,nTmpDimsS))  !they can all share this
       allocate (lhsS(nnz_tot,nsclrsol))
c
c actually they could even share with atemp but leave that for later
c
      else
         nPermDimsS = 0
         nTmpDimsS  = 0
      endif
c
c...  prepare lumped mass if needed
c
c      if((flmpr.ne.0).or.(flmpl.ne.0)) call genlmass(x, shp,shgl)
      call genlmass(x, shp, shgl, iBC, iper, ilwork)
c... compute element volumes
c
      allocate(elem_local_size(numel))
      if (numelb .gt. 0) then
        allocate(elemb_local_size(numelb))
      else
	allocate(elemb_local_size(1))
      endif
      call getelsize(x,  shp,  shgl,  elem_local_size,
     &               shpb, shglb,  elemb_local_size)
c
c Can determine psuedo time step for redistancing now that 
c element size is known
c
      if (i_dtlset_cfl .eq. 1) then
        elem_size_min = minval(elem_local_size)
        if(numpe. gt. 1) then
           call MPI_ALLREDUCE (elem_size_min, elem_size_mintmp, 1,
     &       MPI_DOUBLE_PRECISION,MPI_MIN, MPI_COMM_WORLD,ierr)
        else
           elem_size_mintmp = elem_size_min
        endif
        elem_size_min = elem_size_mintmp
        dtlset = dtlset_cfl * elem_size_min
      endif 
c
c.... -----------------> End of initialization <-----------------
c
c.....open the necessary files to gather time series
c
      lstep0 = lstep+1
c
c.... loop through the time sequences
c


      do 3000 itsq = 1, ntseq
         itseq = itsq

CAD         tcorecp1 = second(0)
CAD         tcorewc1 = second(-1)
c
c.... set up the time integration parameters
c         
         nstp   = nstep(itseq)
         nitr   = niter(itseq)
         LCtime = loctim(itseq)
         dtol(:)= deltol(itseq,:)

         call itrSetup ( y, acold )
c IRENE: THIS SHOULD GO IN A SUBROUTINE
c...initialize the coefficients for the impedance convolution,
c   which are functions of alphaf so need to do it after itrSetup
         if(numImpSrfs.gt.zero) then
            allocate (ConvCoef(ntimeptpT+2,2)) !same time discret. for all imp. BC
            do j=1,ntimeptpT+2
                ConvCoef(j,:)=Delt(1)/2.0
            enddo
            ConvCoef(1,1)=ConvCoef(1,1)*(1.0-alfi)*(1.0-alfi)
            ConvCoef(1,2)=zero
            ConvCoef(2,2)=-ConvCoef(2,2)*(1.0-alfi)*(1.0-alfi)
            ConvCoef(ntimeptpT+1,1)=ConvCoef(ntimeptpT+1,1)*
     &                              alfi*(2.0-alfi)
            ConvCoef(ntimeptpT+2,2)=ConvCoef(ntimeptpT+2,2)*alfi*alfi
            ConvCoef(ntimeptpT+2,1)=zero  
            ConvCoef=ConvCoef/(ntimeptpT*Delt(1)) !divide by period T=N*dt
c
c...calculate the coefficients for the impedance convolution
c 
            allocate (ImpConvCoef(ntimeptpT+2,numImpSrfs))
            do j=2,ntimeptpT+1
                ImpConvCoef(j,:) = ValueListImp(j-1,:)*ConvCoef(j,2)
     &                             + ValueListImp(j,:)*ConvCoef(j,1)  
            enddo
            ImpConvCoef(1,:) = ValueListImp(1,:)*ConvCoef(1,1)
            ImpConvCoef(ntimeptpT+2,:) = 
     &           ValueListImp(ntimeptpT+1,:)*ConvCoef(ntimeptpT+2,2)
         endif
c
c  find the last solve of the flow in the step sequence so that we will
c         know when we are at/near end of step
c
c         ilast=0
         nitr=0  ! count number of flow solves in a step (# of iterations)
         do i=1,seqsize
            if(stepseq(i).eq.0) nitr=nitr+1
         enddo

         if (numpe > 1) call MPI_BARRIER(MPI_COMM_WORLD, ierr)
         if(myrank.eq.0)  then
            tcorecp1 = TMRC()
         endif

c
c.... loop through the time steps
c
         istop=0
         rmub=datmat(1,2,1)
         if(rmutarget.gt.0) then
            rmue=rmutarget
         else
            rmue=datmat(1,2,1) ! keep constant
         endif
         do 2000 istp = 1, nstp

           call rerun_check(stopjob)
           if(stopjob.ne.0) goto 2001
c
c Modify time step based on CFL number
c
           call calc_delt(istp)
c 
            xi=istp*1.0/nstp
            datmat(1,2,1)=rmub*(1.0-xi)+xi*rmue
c            write(*,*) "current mol. visc = ", datmat(1,2,1)
c.... if we have time varying boundary conditions update the values of BC.
c     these will be for time step n+1 so use lstep+1
c     
c           if(itvn.gt.0) call BCint((lstep)*Delt(1), shp, shgl, 
c    &                               shpb, shglb, x, BC, iBC)
            if(itvn.gt.0) call BCint(time,shp, shgl, 
     &                               shpb, shglb, x, BC, iBC)
            if(itvbc.gt.0) call setBC(time, x, iBC, BC)
c
c ... calculate the pressure contribution that depends on the history 
c     for the impendance BC
c
            if(numImpSrfs.gt.0) call pHist(pold,QHistImp,ImpConvCoef,
     &                                          ntimeptpT,numImpSrfs)
c
c Decay of scalars
c
           if(nsclr.gt.0 .and. tdecay.ne.1) then
              yold(:,6:ndof)=y(:,6:ndof)*tdecay
              BC(:,7:6+nsclr)= BC(:,7:6+nsclr)*tdecay
           endif

           if(nosource.eq.1) BC(:,7:6+nsclr)= BC(:,7:6+nsclr)*0.8


            if(iLES.gt.0) then  !complicated stuff has moved to
                                        !routine below
               call lesmodels(yold,  acold,     shgl,      shp, 
     &                        iper,  ilwork,    rowp,      colm,
     &                        nsons, ifath,     x,   
     &                        iBC,   BC)

            
            endif

c.... set traction BCs for modeled walls
c
            if (itwmod.ne.0) then
               call asbwmod(yold,   acold,   x,      BC,     iBC,
     &                      iper,   ilwork,  ifath,  velbar)
            endif
c
c.... -----------------------> predictor phase <-----------------------
c
            call itrPredict(yold, y,   acold,  ac ,  uold,  u)
            call itrBC (y,  ac,  iBC,  BC,  iper,ilwork)

            if(nsolt.eq.1) then
               isclr=0
               call itrBCSclr (y, ac,  iBC, BC, iper, ilwork)
            endif
            do isclr=1,nsclr
               call itrBCSclr (y, ac,  iBC, BC, iper, ilwork)
            enddo
            iter=0
            ilss=0  ! this is a switch thrown on first solve of LS redistance
c
c set the initial tolerance for the redistance loop
c
            if (i_redist_loop_flag.eq.1) then
	      redist_toler_previous = 100.0
	    endif
c
c LOOP OVER SEQUENCES
c
            do istepc=1,seqsize
               icode=stepseq(istepc)
               i_redist_counter=0
c
c***************START of loop condition for Redistancing equation*********************
c Setup start of redistance loop
c
c The concept is to bypass this logic for the first icode=20 when isclr!=2
c and compute the total residual.  The logic will keep the solves/updates
c in the redistance loop until either the maximum number of iterations
c or the residual level is reached.  The loop exists between line numbers
c 781 and just above 809.  Upon exiting the loop any further 20 21 sequences are ignored.
c That is the purpose of the first if statement in the loop.
c

               if ((i_redist_loop_flag.eq.1).and.(istepc.gt.1)) then 
c* if we using loop condition for redistance equation, it is enough to solve
c* once (until the tolerance is defined, of course)                 
                if((stepseq(istepc-1).eq.20) .or. 
     &             (stepseq(istepc-1).eq.21)) then
c                 write(*,*) "we already solved and updated redistance"
                 goto 809
                endif
c                     
 781            if((ilset.eq.2).and.(isclr.eq.2)) then !redistance condition
                  if(icode.eq.20) then
                   i_redist_counter=i_redist_counter+1
                  endif !make sure that we not counting twise
                  if (myrank.eq.master) then !debugging stuff
c                   write(*,*) "Iteration #",i_redist_counter
c                   write(*,*) "icode value=",icode
                  endif ! this condition should be remove later
                endif ! end of redistance condition
               endif! end of loop condition
c
c***************End of loop condition for Redistancing equation*********************
c
               if(mod(icode,5).eq.0) then ! this is a solve
                  isolve=icode/10
                  if(icode.eq.0) then ! flow solve (encoded as 0)
c
                     iter   = iter+1
                     ifuncs(1)  = ifuncs(1) + 1
c     
                     Force(1) = zero
                     Force(2) = zero
                     Force(3) = zero
                     HFlux    = zero
                     entrop   = zero
                     lhs = 1 - min(1,mod(ifuncs(1)-1,LHSupd(1))) 

                     call SolFlow(y,          ac,        u,
     &                         yold,          acold,     uold,
     &                         x,             iBC,
     &                         BC,            res,
     &                         nPermDims,     nTmpDims,  aperm,
     &                         atemp,         iper,          
     &                         ilwork,        shp,       shgl,
     &                         shpb,          shglb,     rowp,     
     &                         colm,          lhsK,      lhsP,
     &                         solinc,        rerr)
                  
                  else          ! scalar type solve
                     if (icode.eq.5) then ! Solve for Temperature
                                ! (encoded as (nsclr+1)*10)
                        isclr=0
                        ifuncs(2)  = ifuncs(2) + 1
                        j=1
                     else       ! solve a scalar  (encoded at isclr*10)
                        isclr=isolve  
                        ifuncs(isclr+2)  = ifuncs(isclr+2) + 1
                        j=isclr+nsolt
                        if((iLSet.eq.2).and.(ilss.eq.0)
     &                       .and.(isclr.eq.2)) then 
                           ilss=1 ! throw switch (once per step)
                           y(:,7)=y(:,6) ! redistance field initialized
                           ac(:,7)   = zero
                           call itrBCSclr (  y,  ac,  iBC,  BC, iper,
     &                          ilwork)
c     
c....store the flow alpha, gamma parameter values and assigm them the 
c....Backward Euler parameters to solve the second levelset scalar
c     
                           alfit=alfi
                           gamit=gami
                           almit=almi
                           Deltt=Delt(1)
                           Dtglt=Dtgl
                           alfi = 1
                           gami = 1
                           almi = 1
c     Delt(1)= Deltt ! Give a pseudo time step
                           Delt(1) = dtlset ! psuedo time step for level set
                           Dtgl = one / Delt(1)
                        endif  ! level set eq. 2
                     endif ! deciding between temperature and scalar

                     lhs = 1 - min(1,mod(ifuncs(isclr+2)-1,
     &                                   LHSupd(isclr+2))) 

                     if((isclr.eq.1.and.iSolvLSSclr1.eq.1) .or. 
     &                  (isclr.eq.2.and.iSolvLSSclr2.eq.1)) then
                      lhs=0
                      call SolSclrExp(y,          ac,        yold,
     &                         acold,         x,         iBC,
     &                         BC,            nPermDimsS,nTmpDimsS,  
     &                         apermS(1,1,j), atempS,    iper,          
     &                         ilwork,        shp,       shgl,
     &                         shpb,          shglb,     rowp,     
     &                         colm,          lhsS(1,j), 
     &                         solinc(1,isclr+5))
                     else
                     call SolSclr(y,          ac,        u,
     &                         yold,          acold,     uold,
     &                         x,             iBC,
     &                         BC,            nPermDimsS,nTmpDimsS,  
     &                         apermS(1,1,j), atempS,    iper,          
     &                         ilwork,        shp,       shgl,
     &                         shpb,          shglb,     rowp,     
     &                         colm,          lhsS(1,j), 
     &                         solinc(1,isclr+5))
                     endif
                        
                  endif         ! end of scalar type solve

               else ! this is an update  (mod did not equal zero)
                  iupdate=icode/10  ! what to update
                  if(icode.eq.1) then !update flow  
                     call itrCorrect ( y,    ac,    u,   solinc)
                     call itrBC (y,  ac,  iBC,  BC, iper, ilwork)
                  else  ! update scalar
                     isclr=iupdate  !unless
                     if(icode.eq.6) isclr=0
                     if(iRANS.lt.0)then  ! RANS
                        call itrCorrectSclrPos(y,ac,solinc(1,isclr+5))
                     else
                        call itrCorrectSclr (y, ac, solinc(1,isclr+5))
                     endif
                     if (ilset.eq.2 .and. isclr.eq.2)  then
                        if (ivconstraint .eq. 1) then
                           call itrBCSclr (  y,  ac,  iBC,  BC, iper,
     &                          ilwork)
c                    
c ... applying the volume constraint on second level set scalar
c
                           call solvecon (y,    x,      iBC,  BC, 
     &                          iper, ilwork, shp,  shgl)
c
                        endif   ! end of volume constraint calculations
                     endif      ! end of redistance calculations
c                     
                        call itrBCSclr (  y,  ac,  iBC,  BC, iper,
     &                       ilwork)
c
c ... update the old value for second level set scalar
c
                     if (ilset.eq.2 .and. isclr.eq.2)  then
                         call itrUpdateDist( yold, acold, y, ac)
                     endif   

                     endif      ! end of flow or scalar update
                  endif         ! end of switch between solve or update
c
c***************Part 2 of loop condition for Redistancing equation*********************
c		  
c Here we test to see if the following conditions are met:
c	no. of redistance iterations < i_redist_max_iter
c	residual (redist_toler_curr) > redist_toler
c If these are true then we continue in the redistance loop
c
                  if(i_redist_loop_flag.eq.1) then !condition for the redistance loop
        
c                  write(808,*) redist_loop
c                  write(*,*) "Tolerance for Redistancing=", redist_toler
c                  write(*,*) "redist_max=", redist_max
                   if((ilset.eq.2).and.(isclr.eq.2)) then !redistance condition
                   if (redist_toler_curr.gt.redist_toler) then !condition 1
                   if (i_redist_counter.lt.i_redist_max_iter) then  ! condition 2
                    if(myrank.eq.master) then
c                     write(*,*) "going to next iteration"
c                    write(*,*) "end:ilset=", ilset
                    endif        
c make sure that switch between solve and update is OK
                    if (icode.eq.20) then !condition 3
                     icode=21
                    else !for condition 3
                     icode=20
c                    write(*,*) "it will be solve of redistance"
                    endif   !end of condition 3
c       end of condition for the solve-update switch
                    if(redist_toler_curr.gt.redist_toler_previous) then
                     if(myrank.eq.master) then
                      write(*,*) "Warning: diverging!"
                     endif
                    endif
                    goto 781
                   else ! for condition 2
                    if(myrank.eq.master) then  
                     write(*,*) "Exceeded Max # of the iterations"
                    endif
                   endif ! end of the condition 2
     
                   endif !end of condition 1
        
                   redist_toler_previous=redist_toler_curr
                   endif !end of the redistance condition
                 endif !end of the condition for the redistance loop		  
c
c***************End of loop condition for Redistancing equation*********************
c		 		  
 809           enddo            ! loop over sequence in step
c
c Check if interface has moved into region of larger interface
c
             if ((iLSet.eq.2).and.(i_check_prox.eq.1)) then 
               call check_proximity(y, stopjob)
	       if(stopjob.ne.0) then
                   lstep = lstep + 1
                   goto 2001
               endif
             endif          
c     
c
c.... obtain the time average statistics
c
            if (ioform .eq. 2) then

               call stsGetStats( y,      yold,     ac,     acold,
     &                           u,      uold,     x,
     &                           shp,    shgl,     shpb,   shglb,
     &                           iBC,    BC,       iper,   ilwork,
     &                           rowp,   colm,     lhsK,   lhsP )
            endif

c     
c  Find the solution at the end of the timestep and move it to old
c
c  
c ...First to reassign the parameters for the original time integrator scheme
c
            if((iLSet.eq.2).and.(ilss.eq.1)) then 
               alfi =alfit
               gami =gamit
               almi =almit 
               Delt(1)=Deltt
               Dtgl =Dtglt
            endif          
            call itrUpdate( yold,  acold,   uold,  y,    ac,   u)
            call itrBC (yold, acold,  iBC,  BC,  iper,ilwork)

            istep = istep + 1
            lstep = lstep + 1
            time  = time + delt(itseq)
c
c... Post process data and write out
c
            if ((i_gradphi.eq.1) .and. (mod(lstep, ntout).eq.0)) then
	      idflx = 0 
              if(idiff >= 1 )  idflx= (nflow-1) * nsd
              if (isurf == 1) idflx=nflow*nsd
	      call getgradphi(x, y, shp,       shgl,
     &                         shpb,          shglb, gradphi)
              gradphimag(:) = ( gradphi(:,1)**2 + 
     &                          gradphi(:,2)**2 + 
     &                          gradphi(:,3)**2 )**0.5
              maxgradphi = maxval(gradphimag)
	      write(*,1000) maxgradphi, myrank
              call MPI_BARRIER(MPI_COMM_WORLD,ierr)
	      call write_gradphi(myrank, lstep, nshg, 3, 
     &                           x, y, gradphi, gradphimag)
 1000 format ("Maximum LS gradient = ",f12.6," on proc",i6)
	    endif
c
c .. write out the solution
c
            if ((irs .ge. 1) .and. (mod(lstep, ntout) .eq. 0)) then
                 call restar ('out ',  yold  ,ac)
c               if(iofieldv.ne.0) then
c                 call pstdrv (y,         ac,         x,
c     &                        iBC,       BC,
c     &                        iper,      ilwork,     shp,
c     &                        shgl,      shpb,       shglb,
c     &                        ifath,     velbar,     nsons )
c
c               endif
               if(ideformwall.eq.1) 
     &              call write_displ(myrank, lstep, nshg, 3, uold ) 
            endif
c SUBROUTINE
c ... update the flow rate history for the impedance convolution
c    
            if(numImpSrfs.gt.zero) then
                call GetFlowQ(NewQImp,y,nsrflistImp,numImpSrfs) !flow Q for imp BC
                do j=1, ntimeptpT
                    QHistImp(j,:)=QHistImp(j+1,:)
                enddo
                QHistImp(ntimeptpT+1,1:numImpSrfs) = 
     &          NewQImp(1:numImpSrfs)

c
c.... write out the new history of flow rates to Qhistor.dat
c      
                if (((irs .ge. 1) .and. (mod(lstep, ntout) .eq. 0)).and.
     &               (myrank .eq. zero)) then
                   open(unit=816, file='Qhistor.dat',status='replace')
                   write(816,*) ntimeptpT
                   do j=1,ntimeptpT+1
                      write(816,*) (QHistImp(j,n),n=1, numImpSrfs)
                   enddo
                   close(816)
                endif
             endif
c
c.... compute the consistent boundary flux
c
            if(abs(itwmod).ne.1) then
               call Bflux ( yold,       acold,      uold,     x,
     &                      shp,       shgl,       shpb,   
     &                      shglb,     ilwork,     iBC,
     &                      BC,        iper)
            endif

c...  dump TIME SERIES
            
            if (exts) then
               
               if (mod(lstep-1,freq).eq.0) then
                  
                  do jj = 1, ntspts
                     
                     if (numpe > 1) then
                        
                        soln = varts(jj)
                        asoln = abs(soln)
                        
c     if(jj.eq.24) then
c     write(*,*) soln
c     write(*,*)"and..."
c     endif
                        
                        if (asoln.ne.zero) then
                           sgn = soln/asoln
                        else
                           sgn = 1
                        endif
                        
                        call MPI_ALLREDUCE ( asoln, asolng, 1, 
     &                       MPI_DOUBLE_PRECISION, MPI_MAX,
     &                       MPI_COMM_WORLD,ierr)
                        varts(jj) = sgn * asolng
                        
                     endif
                     
                     if (myrank.eq.zero) then
                        ifile = 1000+jj
                        write(ifile,555) varts(jj)
                        call flush(ifile)
                     endif
                     
                  enddo
                  
                  
                  varts = zero  ! reset the array for next step
                  
 555              format(e18.11)
                  
               endif
               
            endif


c
c.... update and the aerodynamic forces
c
            call forces ( yold,  ilwork )
            
            if((irscale.ge.0).or.(itwmod.gt.0)) 
     &           call getvel (yold,     ilwork, iBC,
     &                        nsons,    ifath, velbar)

            if((irscale.ge.0).and.(myrank.eq.master)) then
               call genscale(yold,       x,       iper, 
     &                       iBC,     ifath,   velbar,
     &                       nsons)
            endif
c
c....  print out results.
c
            ntoutv=max(ntout,100)   ! velb is not needed so often
            if ((irs .ge. 1) .and. (mod(lstep, ntout) .eq. 0)) then
               if( (mod(lstep, ntoutv) .eq. 0) .and.
     &              ((irscale.ge.0).or.(itwmod.gt.0) .or. 
     &              ((nsonmax.eq.1).and.(iLES.gt.0))))
     &              call rwvelb  ('out ',  velbar  ,ifail)
            endif
c
c.... end of the NSTEP and NTSEQ loops
c
c
c.... -------------------> error calculation  <-----------------
c 
            if(ierrcalc.eq.1 .or. ioybar.eq.1) then
c$$$c
c$$$c compute average
c$$$c
c$$$               tfact=one/istep
c$$$               ybar =tfact*yold + (one-tfact)*ybar

c compute average
c ybar(:,1) - ybar(:,3) is average velocity components
c ybar(:,4) is average pressure
c ybar(:,5) is average speed
c averaging procedure justified only for identical time step sizes
c istep is number of time step
c
               tfact=one/istep

c ybar to contain the averaged ((u,v,w),p)-field
c and speed average, i.e., sqrt(u^2+v^2+w^2)

               ybar(:,1) = tfact*yold(:,1) + (one-tfact)*ybar(:,1)
               ybar(:,2) = tfact*yold(:,2) + (one-tfact)*ybar(:,2)
               ybar(:,3) = tfact*yold(:,3) + (one-tfact)*ybar(:,3)
               ybar(:,4) = tfact*yold(:,4) + (one-tfact)*ybar(:,4)
               ybar(:,5) = tfact*sqrt(yold(:,1)**2+yold(:,2)**2+
     &                     yold(:,3)**2) + (one-tfact)*ybar(:,5)
c
c compute rms
c
               rerr(:, 7)=rerr(:, 7)+(yold(:,1)-ybar(:,1))**2
               rerr(:, 8)=rerr(:, 8)+(yold(:,2)-ybar(:,2))**2
               rerr(:, 9)=rerr(:, 9)+(yold(:,3)-ybar(:,3))**2
               rerr(:,10)=rerr(:,10)+(yold(:,4)-ybar(:,4))**2
c
c.....smooth the error indicators
c
               do i=1,ierrsmooth
                 call errsmooth( rerr, x, iper, ilwork, shp, shgl, iBC )
               end do
c
c.... open the output file
c
               if ((irs .ge. 1) .and. (mod(lstep, ntout) .eq. 0)) then
                 iqoldsiz=nshg*ndof*2
                 call write_error(myrank, lstep, nshg, numerr, rerr )
               endif
            endif
            
            if(istop.eq.1000) exit ! stop when delta small (see rstatic)
 2000    continue
 2001    continue
        

CAD         tcorecp2 = second(0)
CAD         tcorewc2 = second(-1)
         
CAD         write(6,*) 'T(core) cpu-wallclock = ',tcorecp2-tcorecp1,
CAD     &                                        tcorewc2-tcorewc1

         if (numpe > 1) call MPI_BARRIER(MPI_COMM_WORLD, ierr)
         if(myrank.eq.0)  then
            tcorecp2 = TMRC()
            write(6,*) 'T(core) cpu = ',tcorecp2-tcorecp1
         endif

 3000 continue
c      open(unit=87,file="spmass.dat",status="unknown")
c      write(87,197)(splag(j),j=1,10)
c      close(87)
 197  format(10(2x,e14.7))
c
c.... ---------------------->  Post Processing  <----------------------
c
c.... print out the last step
c
      if ((irs .ge. 1) .and. ((mod(lstep, ntout) .ne. 0) .or.
     &     (nstp .eq. 0) .or. (stopjob.ne.0) )) then
         if(
     &              ((irscale.ge.0).or.(itwmod.gt.0) .or. 
     &              ((nsonmax.eq.1).and.iLES.gt.0)))
     &              call rwvelb  ('out ',  velbar  ,ifail)
         call restar ('out ',  yold  ,ac)
c         if(iofieldv.ne.0)
c     &           call pstdrv (yold,      ac,         x,
c     &                        iBC,       BC,
c     &                        iper,      ilwork,     shp,
c     &                        shgl,      shpb,       shglb,
c     &                        ifath,     velbar,     nsons )
         if (i_gradphi.eq.1) then
	    idflx = 0 
            if(idiff >= 1 )  idflx= (nflow-1) * nsd
            if (isurf == 1) idflx=nflow*nsd
	    call getgradphi(x, y, shp,       shgl,
     &                      shpb,          shglb, gradphi)
            gradphimag(:) = ( gradphi(:,1)**2 + 
     &                        gradphi(:,2)**2 + 
     &                        gradphi(:,3)**2 )**0.5
            maxgradphi = maxval(gradphimag)
	    write(*,1000) maxgradphi, myrank
            call MPI_BARRIER(MPI_COMM_WORLD,ierr)
	    call write_gradphi(myrank, lstep, nshg, 3, 
     &                           x, y, gradphi, gradphimag)
	 endif
         if(ideformwall.eq.1) 
     &        call write_displ(myrank, lstep, nshg, 3, u ) 
      endif


         lesId   = numeqns(1)
         call saveLesRestart( lesId,  aperm , nshg, myrank, lstep,
     &                        nPermDims )


      if(ierrcalc.eq.1) then
c
c.....smooth the error indicators
c
        do i=1,ierrsmooth
            call errsmooth( rerr, x, iper, ilwork, shp, shgl, iBC )
        end do
c
c.... open the output file
c
         iqoldsiz=nshg*ndof*2
           call write_error(myrank, lstep, nshg, numerr, rerr ) 
      endif

      if(ioybar.eq.1) then

         itmp = 1
         if (lstep .gt. 0) itmp = int(log10(float(lstep)))+1
         write (fmt2,"('(''restart.'',i',i1,',1x)')") itmp
         write (fname2,fmt2) lstep

         fname2 = trim(fname2) // cname(myrank+1)
c
c.... open  files
c
         call openfile(  fname2,  'append?', irstin )

         fnamer2 = 'ybar'
         isize = nshg*5
         nitems = 3
         iarray(1) = nshg
         iarray(2) = 5
         iarray(3) = lstep
         call writeheader(irstin, fnamer2,iarray, nitems, isize,
     &        'double', iotype )

         nitems = nshg*5
         call writedatablock(irstin, fnamer2,ybar, nitems,
     &        'double', iotype)

         call closefile( irstin, "append" )

      endif

      if ( ( ihessian .eq. 1 ) .and. ( numpe < 2 )  )then
          uhess = zero
          gradu = zero
          tf = zero

          do ku=1,nshg
c           tf(ku,1) = x(ku,1)**2+2*x(ku,1)*x(ku,2)
            tf(ku,1) = x(ku,1)**3
          end do

          call hessian( yold, x,     shp,  shgl,   iBC, 
     &                  shpb, shglb, iper, ilwork, uhess, gradu )

          call write_hessian( uhess, gradu, nshg )
      endif
c
c write phasta status file
c
      call MPI_BARRIER(MPI_COMM_WORLD,ierr)
      if (myrank .eq. master) then
ccc         open (unit=istat,  file=fstat,  status='unknown')
ccc         write(istat,*) "done"
      endif
ccc      close(istat)
c
c.... close history and aerodynamic forces files
c
      if (myrank .eq. master) then
         close (ihist)
         close (iforce)
         if(exts) then
            do jj=1,ntspts
               close(1000+jj)
            enddo
         endif
      endif
      do isrf = 0,MAXSURF
         if ( nsrflist(isrf).ne.0 ) then
            iunit=60+isrf
            close(iunit)
         endif
      enddo
 5    format(1X,F15.10,3X,F15.10,3X,F15.10,3X,F15.10)
 444  format(6(2x,e14.7))
c
c.... end
c
      if(nsolflow.eq.1) then
         deallocate (lhsK)
         deallocate (lhsP)
         deallocate (aperm)
         deallocate (atemp)
      endif
      if(nsclrsol.gt.0) then
         deallocate (lhsS)
         deallocate (apermS)
         deallocate (atempS)
      endif
      
      if(iabc==1) deallocate(acs)

      return
      end
      
      subroutine lesmodels(y,     ac,        shgl,      shp, 
     &                     iper,  ilwork,    rowp,      colm,    
     &                     nsons, ifath,     x,   
     &                     iBC,   BC)
      
      include "common.h"

      real*8    y(nshg,ndof),              ac(nshg,ndof),           
     &            x(numnp,nsd),
     &            BC(nshg,ndofBC)
      real*8    shp(MAXTOP,maxsh,MAXQPT),  
     &            shgl(MAXTOP,nsd,maxsh,MAXQPT)

c
      integer   rowp(nshg,nnz),         colm(nshg+1),
     &            iBC(nshg),
     &            ilwork(nlwork),
     &            iper(nshg)
      dimension ifath(numnp),    nsons(nfath)

      real*8, allocatable, dimension(:) :: fwr2,fwr3,fwr4
      real*8, allocatable, dimension(:) :: stabdis,cdelsq1
      real*8, allocatable, dimension(:,:) :: xavegt, xavegt2,xavegt3

      if( (iLES.gt.1) )   then ! Allocate Stuff for advanced LES models
         allocate (fwr2(nshg))
         allocate (fwr3(nshg))
         allocate (fwr4(nshg))
         allocate (xavegt(nfath,12))
         allocate (xavegt2(nfath,12))
         allocate (xavegt3(nfath,12))
         allocate (stabdis(nfath))
      endif

c.... get dynamic model coefficient
c
      ilesmod=iLES/10  
c
c digit bit set filter rule, 10 bit set model
c
      if (ilesmod.eq.0) then    ! 0 < iLES< 10 => dyn. model calculated
                                ! at nodes based on discrete filtering


         if(isubmod.eq.2) then
            call SUPGdis(y,      ac,        shgl,      shp, 
     &                   iper,   ilwork,    
     &                   nsons,  ifath,     x,   
     &                   iBC,    BC, stabdis, xavegt3)
         endif

         if( ((isubmod.eq.0).or.(isubmod.eq.2)))then ! If no
                                                     ! sub-model
                                                     ! or SUPG
                                                     ! model wanted

            if(i2filt.eq.0)then ! If simple filter
              
               if(modlstats .eq. 0) then ! If no model stats wanted
                  call getdmc (y,       shgl,      shp, 
     &                         iper,       ilwork,    nsons,
     &                         ifath,      x)
               else             ! else get model stats 
                  call stdfdmc (y,       shgl,      shp, 
     &                          iper,       ilwork,    nsons,
     &                          ifath,      x)
               endif            ! end of stats if statement  

            else                ! else if twice filtering

               call widefdmc(y,       shgl,      shp, 
     &                       iper,       ilwork,    nsons,
     &                       ifath,      x)

               
            endif               ! end of simple filter if statement

         endif                  ! end of SUPG or no sub-model if statement


         if( (isubmod.eq.1) ) then ! If DFWR sub-model wanted
            call cdelBHsq (y,       shgl,      shp, 
     &                     iper,       ilwork,    nsons,
     &                     ifath,      x,         cdelsq1)
            call FiltRat (y,       shgl,      shp, 
     &                    iper,       ilwork,    nsons,
     &                    ifath,      x,         cdelsq1,
     &                    fwr4,       fwr3)

            
            if (i2filt.eq.0) then ! If simple filter wanted
               call DFWRsfdmc(y,       shgl,      shp, 
     &                        iper,       ilwork,    nsons,
     &                        ifath,      x,         fwr2, fwr3) 
            else                ! else if twice filtering wanted 
               call DFWRwfdmc(y,       shgl,      shp, 
     &                        iper,       ilwork,    nsons,
     &                        ifath,      x,         fwr4, fwr4) 
            endif               ! end of simple filter if statement
             
         endif                  ! end of DFWR sub-model if statement

         if( (isubmod.eq.2) )then ! If SUPG sub-model wanted
            call dmcSUPG (y,           ac,         shgl,      
     &                    shp,         iper,       ilwork,    
     &                    nsons,       ifath,      x,
     &                    iBC,    BC,  rowp,       colm,
     &                    xavegt2,    stabdis)
         endif

         if(idis.eq.1)then      ! If SUPG/Model dissipation wanted
            call ediss (y,        ac,      shgl,      
     &                  shp,      iper,       ilwork,    
     &                  nsons,    ifath,      x,
     &                  iBC,      BC,  xavegt)
         endif

      endif                     ! end of ilesmod
      
      if (ilesmod .eq. 1) then  ! 10 < iLES < 20 => dynamic-mixed
                                ! at nodes based on discrete filtering
         call bardmc (y,       shgl,      shp, 
     &                iper,    ilwork,    
     &                nsons,   ifath,     x) 
      endif
      
      if (ilesmod .eq. 2) then  ! 20 < iLES < 30 => dynamic at quad
                                ! pts based on lumped projection filt. 

         if(isubmod.eq.0)then
            call projdmc (y,       shgl,      shp, 
     &                    iper,       ilwork,    x) 
         else
            call cpjdmcnoi (y,      shgl,      shp, 
     &                      iper,   ilwork,       x,
     &                      rowp,   colm, 
     &                      iBC,    BC)
         endif

      endif

      if( (iLES.gt.1) )   then ! Deallocate Stuff for advanced LES models
         deallocate (fwr2)
         deallocate (fwr3)
         deallocate (fwr4)
         deallocate (xavegt)
         deallocate (xavegt2)
         deallocate (xavegt3)
         deallocate (stabdis)
      endif
      return
      end
