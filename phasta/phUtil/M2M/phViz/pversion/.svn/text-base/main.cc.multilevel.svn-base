#include <iostream>
#include <cstdlib>  // for NULL

#include "MeshSim.h"
#include "phastaIO.h"
#include "SimMeshTools.h"
#include "Solution.h"
#include "SimParasolidKrnl.h"
#include "MeshSimAdapt.h"


using std::endl; 
using std::cout;
using std::cin;

extern "C" int readLicenseFile(char *filename);
extern "C" void fix4NodesOnSurface(pMesh mesh);

pMeshDataId reflevel ;
void writeArrayToFile( char *filename,
		       char *fieldName,
		       char *outputFormat,
		       char *mode,
		       int nshg,
		       int ndof,
		       int stepNumber,
		       double *valueArray) {
 
  int restart;
  char fname[256];
  int iarray[10];
  int size, nitems;
  
  openfile_( filename, mode, &restart );

  writestring_( &restart,"# PHASTA Input File Version 2.0\n");
  writestring_( &restart, "# Byte Order Magic Number : 362436 \n");

  sprintf(fname,"# Output generated by phAdapt version: %s \n");
  writestring_( &restart, fname );

  time_t timenow = time ( &timenow);
  sprintf(fname,"# %s\n", ctime( &timenow ));
  writestring_( &restart, fname );

  size = 1;
  nitems = 1;
  iarray[0] = 1;
  int magic_number = 362436;
  int* mptr = &magic_number;

  writeheader_( &restart, "byteorder magic number ",
		(void*)iarray, &nitems, &size, "integer", outputFormat );

  writedatablock_( &restart, "byteorder magic number ",
		   (void*)mptr, &nitems, "integer", outputFormat );          

  bzero( (void*)fname, 256 );
  sprintf(fname,"number of modes : < 0 > %d\n", nshg);
  writestring_( &restart, fname );
    
  bzero( (void*)fname, 256 );
  sprintf(fname,"number of variables : < 0 > %d\n", ndof);
  writestring_( &restart, fname );
    
  size =  nshg*ndof;
  nitems = 3; // length of array
  iarray[0] = nshg;
  iarray[1] = ndof;
  iarray[2] = stepNumber;

  writeheader_( &restart, fieldName,
		( void* )iarray, &nitems, &size,"double", outputFormat );

  nitems = nshg*ndof; // length of array
  writedatablock_( &restart, fieldName,
		   ( void* )(valueArray), &nitems, "double", outputFormat );

  closefile_( &restart, mode);
}

void
transferRefLevel( MeshModType mtype, pMeshChanges mco, void* UserData ) {

    pPList oregions = MCO_getDeletedEntities( mco );
    pPList nregions = MCO_getCreatedEntities( mco );
    int maxreflevel = 0;
    void* tmp = 0; 
    pRegion region;
    while( region = (pRegion)PList_next( oregions, &tmp ) ) {
        int tmpreflevel = 0 ;
        EN_getDataInt( (pEntity) region, reflevel, &tmpreflevel );
        if ( tmpreflevel > maxreflevel ) maxreflevel = tmpreflevel ;
    }
    PList_delete( oregions );
    tmp = 0; 
    while( region = (pRegion)PList_next( nregions, &tmp ) ) {
        EN_attachDataInt( (pEntity)region, reflevel, maxreflevel );
    }
    PList_delete( nregions );
}

void
markForRefinement( char *solfile, 
                   pMesh mesh, 
                   pMeshDataId reflevel ) {
    
    double* soln;
    int ione =1;
    int iarray[2]={-1,-1};
    pPList regions;
    pRegion region;
    void* tmp=0;
    int ireflevel;

    RIter rIter = M_regionIter( mesh );
    while ( region = RIter_next( rIter ) ) {
        EN_attachDataInt( (pEntity)region, reflevel, 0 );
    }

    int irestart;
    openfile_( solfile , "read",  &irestart );

    iarray[0]=-1;
    iarray[1]=-1;
    int itwo=2;
    readheader_( &irestart, "edge mode mapping to sms", iarray, &itwo,
                 "integer", "binary");
    int size = iarray[0];
    int nmodes = iarray[0];
    if ( size > 0 ) {
        int* rmap = new int [ size ];
        readdatablock_( &irestart, "edge mode mapping to sms", rmap,
                        &size, "integer", "binary");
        int* ptr = rmap;
        int nem;
        pEdge edge;
        int ecounter =0;
        EIter eIter = M_edgeIter( mesh );
        while ( (edge = EIter_next( eIter )) && (ecounter < nmodes )) {
            if ( EN_id( (pEntity)edge ) == *(ptr) ) {
                ptr++;
                nem = *(ptr++);
                ecounter += nem;

                tmp=0;
                regions = E_regions( edge ) ;
                while( region =(pRegion)PList_next( regions, &tmp ) ) {
                    ireflevel = 0;
                    EN_getDataInt( (pEntity)region, reflevel, &ireflevel );
                    if ( ireflevel < nem  ) {
                        EN_modifyDataInt( (pEntity) region, reflevel, nem );
                    }
                }
                PList_delete( regions );
                
                /* EN_attachDataInt(edge,reflevel, nem ); */
                /* MSA_setRefineLevel(simAdapter,(pEntity)edge,nem); */
                while( nem-- ) ptr++;
            }
        }
        EIter_delete( eIter );
        delete [] rmap;
    }
    
    iarray[0]=-1;
    iarray[1]=-1;
    readheader_( &irestart, "face mode mapping to sms", iarray, &itwo,
                 "integer", "binary");
    size = iarray[0];
    nmodes = iarray[0];

    if ( size > 0 ) {
        int* rmap = new int [ size ];
        readdatablock_( &irestart, "face mode mapping to sms", rmap,
                        &size, "integer", "binary");
        int* ptr = rmap;
        int nem;
        pFace face ;
        int fcounter=0;
        FIter fIter = M_faceIter( mesh );
        while( ( face = FIter_next( fIter ) ) && ( fcounter < nmodes )) {
            if ( EN_id( (pEntity)face ) == *(ptr) ) {
                ptr++;
                nem = *(ptr++);
                if ( nem > 0 ) {
                    if ( nem > 1 )  {
                        cerr << "face cannot have 2 modes at the moment" << endl;
                        cerr << "please check  :" << __FILE__ << endl;
                        exit(0);
                    }
                    fcounter += nem;
                    tmp=0;
                    regions = F_regions( face ) ;
                    while( region = (pRegion)PList_next( regions, &tmp ) ) {
                        ireflevel = 0;
                        EN_getDataInt( (pEntity)region, reflevel, &ireflevel );
                        if ( ireflevel < 2  ) {
                            EN_modifyDataInt( (pEntity) region, reflevel, 2 );
                        }
                    }
                    PList_delete( regions );
                    /* MSA_setRefineLevel(simAdapter,(pEntity)face,1); */
                    /* loop over mesh edges of the face */
                    /* EN_attachDataInt(edge,reflevel, nem ); */
                    while( nem-- ) ptr++;
                }
            }
        }
        FIter_delete( fIter );
        delete[] rmap;
    }
    closefile_( &irestart, "read");
}

int 
main(int argc, char *argv[])
{

  int ndof = 5 ;
  if ( !strcmp( argv[1], "--help") ) {
    cout << "Usage: " << endl;
    cout << argv[0] << "gmodel pversionMesh pversionSolution hversionSolution fieldname" << endl;
    exit( 0 );
  }

  if ( argc >6 ) ndof = atoi( argv[6] );

  readLicenseFile(NULL);
  MS_init();

  pGModel model;
  pMesh pversionMesh, hversionMesh; 

  SimParasolid_start(1);
  model  = GM_createFromParasolidFile(argv[1]);
  pversionMesh = MS_newMesh(model);
  hversionMesh = MS_newMesh(model);
  M_load(pversionMesh,argv[2]);
  M_load(hversionMesh,argv[2]);

  //adapt mesh

  reflevel = MD_newMeshDataId("refinement level");
  markForRefinement( argv[3], hversionMesh, reflevel );
  bool notdone = true;
  int refcounter = 0;

  while ( notdone ) {
      notdone = false;
      pMSAdapt simAdapter = MSA_new(hversionMesh,0);
      MSA_setCallback( simAdapter, transferRefLevel , 8, NULL );
      RIter rIter = M_regionIter( hversionMesh );
      while ( pRegion region = RIter_next( rIter ) ) {
          int iref = 0;
          EN_getDataInt( (pEntity)region, reflevel, &iref );
          if ( iref > refcounter ) {
              notdone = true;
              MSA_setRefineLevel(simAdapter,(pEntity)region,1);
          }
      }
      if( notdone ) MSA_adapt(simAdapter);
      refcounter++;
      MSA_delete(simAdapter);
  }

  fix4NodesOnSurface(hversionMesh);
  printf("\n Writing out the adapted mesh...\n\n");
  M_writeSMS(hversionMesh,"adapted.sms",5);

 //project solution
  pMeshDataId pversionSolution = MD_newMeshDataId("padapted solution data");
  pMeshDataId nelmodes  = MD_newMeshDataId("number of modes per entity");
  attachSolution( argv[3] , pversionMesh, pversionSolution,  nelmodes,argv[5], ndof);
  pMeshRegionFinder mrf = MeshRegionFinder_new(pversionMesh,1,0);
  pVertex vtx;
  VIter vIter = M_vertexIter(hversionMesh);
  int nshg = M_numVertices( hversionMesh );
  int vcounter = 0;
  double* q = new double [ (ndof+1) * nshg ];

  while(vtx = VIter_next(vIter)) {
      double d_xyz[3];
      double d_xi[3]={0.0,0.0,0.0};
      V_coord(vtx,d_xyz);
      int foundRegion = 0;
      double distance;
      pRegion region = MeshRegionFinder_find(mrf,d_xyz,d_xi,&distance);
      if(region) {
          //project the solution onto this vtx point and attach it 
          double* qvtx = getSolution( d_xyz, region, pversionSolution, nelmodes, d_xi,  ndof );
          if ( qvtx )  {
            for( int dof = 0 ; dof < ndof+1 ; dof++ ) 
                q[ dof*nshg + vcounter ] = qvtx[ dof ];
            delete [] qvtx;
          } else {
              cerr << "Couldn't map vertex (" << d_xyz[0] <<" " << d_xyz[1] <<" " << d_xyz[2] << ")" <<endl;
          }
      } else {
          cerr << "Couldn't locate vertex (" << d_xyz[0] <<" " << d_xyz[1] <<" " << d_xyz[2] << ")" <<endl;
      }
      vcounter++;
  }
  MS_deleteMesh(pversionMesh);
  MS_deleteMesh(hversionMesh);
  MD_deleteMeshDataId(pversionSolution);

  writeArrayToFile( argv[4], argv[5], "binary", "write", nshg, ndof+1, 0, q );

  delete [] q ;
  GM_delete(model);
  SimParasolid_stop(1);
  MS_exit();
  return 0;
}
